

imports
{


import Data.List
import Text.Parsec.Prim
import N3grammar
--import Text.PrettyPrint
--import Text.PrettyPrint.HughesPJ


}

--N3 Grammar
data S
    | Mainformula f :: Formula
 
data Formula
   | Triple s, p, o :: Term
   | Implication e1, e2 :: Expression
   | Conjunction c1, c2 :: Formula

data Term
   | Universal u :: String
   | Existential ex :: String
   | URI uri :: String
   | Literal l :: String
   | Exp  e :: Expression
   | List term, list :: Term


data Expression
   | BE   b  :: Bool
   | FE   f  :: Formula

deriving S Term Expression Formula: Show
deriving S Formula Term Expression : Read


--Core Grammar
data CFormula
     | CTriple t1, t2, t3 :: CTerm
     | CImplication e1, e2 :: CExpression
     | CConjunction f1, f2 :: CFormula
     | Quant     a :: Quant
                 f :: CFormula

data Quant 
     | Forall v :: CTerm
     | Forsome e :: CTerm



data CTerm 
     | Var t :: String
     | Con c :: String
     | CExp  e :: CExpression
     | CList t, list :: CTerm

data CExpression
   | CBE   b  :: Bool
   | CFE   f  :: CFormula


deriving CTerm  CFormula Quant Var CTerm CExpression: Show



-- Attributes for N3 Grammar
--Declaration
attr S
--Attributes for standard--
   syn n1 :: {[String]}
   syn n2 :: {[String]}
   syn ex :: {[String]}
   syn transformed :: CFormula
   syn formula ::  String
--attributes for EYE--
   syn eye :: CFormula
   syn eyeVar :: {[String]}
   syn eyeEx :: {[String]}
   

attr Formula
--Attributes for standard--
   syn n2 :: {[String]}
   syn n1 :: {[String]}
   inh scope :: {[String]}
   inh uni   :: {[String]}
   syn ex :: {[String]}
   syn transformed :: CFormula
   syn formula :: String
--attributes for EYE--
   syn eye :: CFormula
   syn eyeVar :: {[String]}
   syn eyeEx :: {[String]}


attr Term
--Attributes for standard--
   syn n2 :: {[String]}
   syn n1 :: {[String]}
   inh scope :: {[String]}
   syn ex :: {[String]}
   syn transformed :: CTerm
   syn formula :: String
--attributes for EYE--
   syn eye :: CTerm
   syn eyeVar :: {[String]}
   syn eyeEx :: {[String]}

attr Expression
--Attributes for standard--
   syn n1 :: {[String]}
   inh scope :: {[String]}
   syn transformed :: CExpression
   syn formula :: String
--attributes for EYE--
   syn eye :: CExpression
   syn eyeVar :: {[String]}
   syn eyeEx :: {[String]}
   inh partOfImp :: Bool


--Definition   
--TODO: default value should be empty list

sem S
   | Mainformula f.scope = @f.n1  `union` @f.n2
                 f.uni   = @f.n1  `union` @f.n2
                 lhs.ex = @f.ex
                 lhs.transformed = qua (@f.n1  `union` @f.n2) @f.ex @f.transformed
                 lhs.formula = quaf  (@f.n1  `union` @f.n2) @f.ex   @f.formula
                 lhs.eye = qua @f.eyeVar @f.eyeEx @f.eye
                 lhs.eyeEx = @f.eyeEx
  
sem Formula
   | Triple lhs.n2 = (@s.n2 `union` @p.n2) `union` @o.n2
            lhs.n1 = (@s.n1 `union` @p.n1) `union` @o.n1 
            lhs.ex = (@s.ex `union` @p.ex) `union` @o.ex 
            lhs.transformed = CTriple @s.transformed @p.transformed @o.transformed 
            lhs.formula =   @s.formula ++ " " ++ @p.formula ++ " " ++ @o.formula 
            lhs.eye = CTriple @s.eye @p.eye @o.eye  
            lhs.eyeVar = (@s.eyeVar `union` @p.eyeVar) `union` @o.eyeVar 
            lhs.eyeEx = (@s.eyeEx `union` @p.eyeEx) `union` @o.eyeEx 
             
 
               
   | Implication lhs.n2 = []
                 lhs.n1 = @e1.n1 `union` @e2.n1
                 lhs.ex = []
                 lhs.transformed = CImplication @e1.transformed @e2.transformed
                 lhs.formula =  @e1.formula ++ " -> " ++ @e2.formula
                 lhs.eye = CImplication @e1.eye @e2.eye
                 lhs.eyeVar = @e1.eyeVar `union` @e2.eyeVar
                 lhs.eyeEx = []
                 e1.partOfImp = True
                 e2.partOfImp = True

   | Conjunction lhs.n2 = @c1.n2 `union` @c2.n2
                 lhs.n1 = @c1.n1 `union` @c2.n1
                 lhs.ex = @c1.ex `union` @c2.ex
                 c1.scope = @lhs.scope
                 c2.scope = @lhs.scope
                 lhs.transformed = CConjunction @c1.transformed @c2.transformed
                 lhs.formula =   @c1.formula ++ " ^ " ++ @c2.formula
                 lhs.eye = CConjunction @c1.eye @c2.eye
                 lhs.eyeVar = @c1.eyeVar `union` @c2.eyeVar
                 lhs.eyeEx = @c1.eyeEx `union` @c2.eyeEx

                 
sem Term
   | Universal lhs.n2 = ["U"++ @u]
               lhs.n1 = []
               lhs.ex = []
               lhs.transformed = Var  ("U"++ @u) 
               lhs.formula = "U"++ @u 
               lhs.eyeVar = ["U" ++ @u]
               lhs.eye = Var  ("U"++ @u)
               lhs.eyeEx = [] 

   | Existential lhs.n2 = []
                lhs.n1 = []
                lhs.ex = ["E"++ @ex]
                lhs.transformed = Var ("E"++ @ex)
                lhs.formula = "E"++ @ex
                lhs.eyeVar = []
                lhs.eye = Var ("E"++ @ex)
                lhs.eyeEx = ["E"++ @ex]

   | URI lhs.n2 = []
              lhs.n1 = []
              lhs.ex = []
              lhs.transformed = Con ("uri_"++ @uri)
              lhs.formula = "uri_"++ @uri
              lhs.eyeVar = []
              lhs.eye = Con ("uri_" ++ @uri)
              lhs.eyeEx = []


   | Literal lhs.n2 = []
              lhs.n1 = []
              lhs.ex = []
              lhs.transformed = Con ("l_"++ @l)
              lhs.formula = "l_"++ @l
              lhs.eyeVar = []
              lhs.eye = Con ("l_"++ @l)
              lhs.eyeEx = []
    
   | Exp  lhs.n2 = []
          lhs.n1 = @e.n1
          lhs.ex = []
          lhs.transformed = CExp @e.transformed 
          lhs.formula =  @e.formula
          lhs.eye = CExp @e.eye
          lhs.eyeEx= @e.eyeEx
          e.partOfImp = False
           
--TODO how to get the transformed values of the elements?
   |List  lhs.n2 = @term.n2 ++ @list.n2
          lhs.n1 = []
          lhs.ex = @term.ex ++ @list.ex
          -- has to be adjusted
          lhs.transformed = CList @term.transformed @list.transformed
          lhs.formula =  "(" ++ @term.formula ++ "," ++ @list.formula ++ ")" 
          lhs.eyeVar = @term.eyeVar ++ @list.eyeVar
          lhs.eye = CList @term.transformed @list.transformed
          lhs.eyeEx = @term.eyeEx ++ @list.eyeEx
                
           
                
                
          

sem Expression
   | BE lhs.n1 = []
          lhs.transformed = CBE @b
          lhs.formula = if @b == True then "<>" else "false"
          lhs.eyeVar = []
          lhs.eye = CBE @b
          lhs.eyeEx = []

   | FE   lhs.n1 = @f.n2
          f.scope = @lhs.scope `union` @f.n1 
          lhs.transformed = CFE (qua (@f.n1 \\ @lhs.scope) @f.ex @f.transformed)  
          lhs.formula = "<"++ (quaf (@f.n1 \\ @lhs.scope) @f.ex @f.formula) ++">"
          f.uni = @f.n1 \\ @lhs.scope
          lhs.eye = CFE (qua [] (imp @lhs.partOfImp @f.eyeEx) @f.eye )
          lhs.eyeEx = @f.eyeEx



{

--TODO: pretty print
--TODO: clean up the ugly function!
{-
main ::  IO ()
main = case parse mainparser "" ":a :b :c." of
              { Left err -> print err
              ; Right ans -> print (  show (  transformed_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  )  )
              }
-}



             
parseToCoreTree :: String -> IO ()
parseToCoreTree filename = do {
                       input <- readFile filename
                       ; case runParser mainparser 0 filename input of
                       {
                       Left err -> print err
                       ; Right ans -> putStrLn $   show (  transformed_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  ) 
                       }
                       }  

              
eyeToCore :: String -> IO ()
eyeToCore fname = do {
               input <- readFile fname
              ; case runParser mainparser 0 fname input of
              { Left err -> print err
              ; Right ans -> putStrLn $ show (  eye_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  )  
              }}

parseToCoreFormula :: String -> IO ()
parseToCoreFormula fname = do {
                input <- readFile fname
                ; case runParser mainparser 0 fname input of
                { Left err -> print err
                ; Right ans -> print (  formula_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  ) )
                }
              }


testp :: String -> IO ()
testp fname = do {
                  input <- readFile fname
                  ; case runParser mainparser 0 fname input of
                  { Left err -> print err
                  ; Right ans -> putStrLn $   show (  eyeVar_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  ) 
                  } 
              }


-- function for quantifiers: takes Universals and existentials as lists and the formula without quantifier and produces a quantified formula
qua :: [String] -> [String] -> CFormula -> CFormula
qua [] [] f  = f
qua [] (a:as) f = Quant (Forsome (Var a)) (qua [] as f)
qua (a:as) g f = Quant (Forall (Var a)) (qua as g f)


--the qua function to generate a formula (just to see the translation as text)
quaf :: [String] -> [String] -> String -> String
quaf [] [] s = s
quaf [] (a:as) s = "ForSome " ++ a ++ ". " ++ (quaf [] as s)
quaf (a:as) g s = "ForAll " ++ a ++ ". " ++ (quaf as g s)


imp :: Bool -> [String] -> [String]
imp True l  = l
imp False l = []

--not really pretty, but at least easy
printTree :: String -> Int -> String 
printTree ('(':b) n = "\n"++ ( concat (replicate (n+1) "|  ") ) ++ ( printTree b (n+1) ) 
printTree (')':b) n = ( printTree b (n-1) )
printTree (s:b)   n  =  (s    : ( printTree b n))
printTree s       n  =  s


makeTree :: String -> String -> IO()
makeTree fname "eye" = do {
                input <- readFile fname
                ; case runParser mainparser 0 fname input of
                { Left err -> print err
                ; Right ans -> putStrLn $ printTree  (show (  eye_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  )) 0
                }}
makeTree fname "cwm" = do {
                input <- readFile fname
                ; case runParser mainparser 0 fname input of
                { Left err -> print err
                ; Right ans -> putStrLn $ printTree  (show  (  transformed_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  )) 0
                }
                }


--really primitive function to compare tree strings, later that comparison should be on tree level
compareTree :: String -> String -> String
compareTree (x:b) (y:c)  
           | (x==y) = compareTree b c
           | otherwise = "Difference \n CWM:  " ++ (take 100 (x:b)) ++ "... \n and \n EYE:  " ++ (take 100 (y:c))++ "..."
compareTree [][] = "no differences found"

compareB :: String -> IO()
compareB fname = do {
               input <- readFile fname
               ; case runParser mainparser 0 fname input of
                        { 
                          Left err -> print err
                          ; Right ans -> putStrLn $  compareTree (show (  transformed_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  )) 
                                                              (show (  eye_Syn_S         (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  ))
                        }
               }





--data TreeElem = CFormula | CTerm

-- function to compare trees
--compareTrees :: TreeElem -> TreeElem -> [(TreeElem, TreeElem)]
--compareTrees (CFormula rest)(CFormula rest2) = compareTrees rest rest2
--compareTrees (CTriple t1 t2 t3)(CTriple t11 t22 t33) = (compareTrees t1 t11)++(compareTrees t2 t22)++(compareTrees t3 t33)
--compareTrees a b = [(a,b)]

--compareTrees (Var x) (Var y) 
--            | (x == y) = []
--            | otherwise = [(x,y)]



}























