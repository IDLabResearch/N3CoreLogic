

imports
{


import Data.List
import Text.Parsec.Prim
import N3grammar
import System.Directory
--import Text.PrettyPrint
--import Text.PrettyPrint.HughesPJ

}

--N3 Grammar
data S
    | Mainformula f :: Formula
 
data Formula
   | Triple s, p, o :: Term
   | Implication e1, e2 :: Expression
   | Conjunction c1, c2 :: Formula

data Term
   | Universal u :: String
   | Existential ex :: String
   | URI uri :: String
   | Literal l :: String
   | Exp  e :: Expression
--this seems to be wrong!
   | List term, list :: Term


data Expression
   | BE   b  :: Bool
   | FE   f  :: Formula

deriving S Term Expression Formula: Show
deriving S Formula Term Expression : Read


--Core Grammar
data CFormula
     | CTriple t1, t2, t3 :: CTerm
     | CImplication e1, e2 :: CExpression
     | CConjunction f1, f2 :: CFormula
     | Quant     a :: Quant
                 f :: CFormula

data Quant 
     | Forall v :: CTerm
     | Forsome e :: CTerm



data CTerm 
     | Var t :: String
     | Con c :: String
     | CExp  e :: CExpression
     | CList t, list :: CTerm

data CExpression
   | CBE   b  :: Bool
   | CFE   f  :: CFormula


deriving CTerm  CFormula Quant Var CTerm CExpression: Show



-- Attributes for N3 Grammar
--Declaration
attr S
--Attributes for standard--
   syn n1 :: {[String]}
   syn n2 :: {[String]}
   syn ex :: {[String]}
   syn transformed :: CFormula
   syn formula ::  String
--attributes for EYE--
   syn eye :: CFormula
   syn eyeVar :: {[String]}
   syn eyeEx :: {[String]}
--like team submission but universal different
   syn diff :: CFormula  
--count how deeply nested universals occur
   syn count :: Int
   

attr Formula
--Attributes for standard--
   syn n2 :: {[String]}
   syn n1 :: {[String]}
   inh scope :: {[String]}
   inh uni   :: {[String]}
   syn ex :: {[String]}
   syn transformed :: CFormula
   syn formula :: String
--attributes for EYE--
   syn eye :: CFormula
   syn eyeVar :: {[String]}
   syn eyeEx :: {[String]}
   inh insideQuotation :: Bool
--like team submission but universal different
   syn diff :: CFormula 
--count how deeply nested universals occur
   syn count :: Int
   inh c :: Int

attr Term
--Attributes for standard--
   syn n2 :: {[String]}
   syn n1 :: {[String]}
   inh scope :: {[String]}
   syn ex :: {[String]}
   syn transformed :: CTerm
   syn formula :: String
--attributes for EYE--
   syn eye :: CTerm
   syn eyeVar :: {[String]}
   syn eyeEx :: {[String]}
   inh insideQuotation :: Bool
   inh varInImpException :: Bool
--like team submission but universal different
   syn diff :: CTerm
--count how deeply nested universals occur
   syn count :: Int
   inh c :: Int

attr Expression
--Attributes for standard--
   syn n1 :: {[String]}
   inh scope :: {[String]}
   syn transformed :: CExpression
   syn formula :: String
--attributes for EYE--
   syn eye :: CExpression
   syn eyeVar :: {[String]}
   syn eyeEx :: {[String]}
   inh insideQuotation :: Bool
--like team submission but universal different
   syn diff :: CExpression  
--count how deeply nested universals occur
   syn count :: Int
   inh c :: Int

--Definition   
--TODO: default value should be empty list

sem S
   | Mainformula f.scope = @f.n1  `union` @f.n2
                 f.uni   = @f.n1  `union` @f.n2
                 lhs.ex = @f.ex
                 lhs.transformed = qua (sort (@f.n1  `union` @f.n2)) @f.ex @f.transformed
                 lhs.formula = quaf (sort  (@f.n1  `union` @f.n2)) @f.ex   @f.formula 
                 lhs.eye = qua (sort @f.eyeVar ) @f.eyeEx @f.eye
                 lhs.eyeEx = @f.eyeEx
                 lhs.eyeVar = @f.eyeVar
                 f.insideQuotation = False
                 lhs.diff = qua (sort  @f.eyeVar) @f.ex @f.diff
                 f.c = 1
                 lhs.count = findDepth @f.n1 1 @f.count
  
sem Formula
   | Triple lhs.n2 = (@s.n2 `union` @p.n2) `union` @o.n2
            lhs.n1 = (@s.n1 `union` @p.n1) `union` @o.n1 
            lhs.ex = (@s.ex `union` @p.ex) `union` @o.ex 
            lhs.transformed = CTriple @s.transformed @p.transformed @o.transformed 
            lhs.formula =   @s.formula ++ " " ++ @p.formula ++ " " ++ @o.formula 
            lhs.eye = CTriple @s.eye @p.eye @o.eye  
            lhs.eyeVar = (@s.eyeVar `union` @p.eyeVar) `union` @o.eyeVar 
            lhs.eyeEx = (@s.eyeEx `union` @p.eyeEx) `union` @o.eyeEx 
            s.insideQuotation = @lhs.insideQuotation
            p.insideQuotation = @lhs.insideQuotation
            o.insideQuotation = @lhs.insideQuotation
            s.varInImpException = impExc @p.eye @lhs.insideQuotation
            p.varInImpException = False
            o.varInImpException = impExc @p.eye @lhs.insideQuotation
            lhs.diff = CTriple @s.diff @p.diff @o.diff 
            s.c = @lhs.c
            p.c = @lhs.c
            o.c = @lhs.c
            lhs.count = max @s.count (max @p.count @o.count)
 
               
   | Implication lhs.n2 = []
                 lhs.n1 = @e1.n1 `union` @e2.n1
                 lhs.ex = []
                 lhs.transformed = CImplication @e1.transformed @e2.transformed
                 lhs.formula =  @e1.formula ++ " -> " ++ @e2.formula
                 lhs.eye = CImplication @e1.eye @e2.eye
                 lhs.eyeVar = @e1.eyeVar `union` @e2.eyeVar
                 lhs.eyeEx = keepEx @lhs.insideQuotation (@e1.eyeEx `union` @e2.eyeEx) 
                 e1.insideQuotation = @lhs.insideQuotation
                 e2.insideQuotation = @lhs.insideQuotation
                 lhs.diff = CImplication @e1.diff @e2.diff
                 e1.c = @lhs.c
                 e2.c = @lhs.c
                 lhs.count = max @e1.count @e2.count

   | Conjunction lhs.n2 = @c2.n2 `union` @c1.n2
                 lhs.n1 = @c2.n1 `union` @c1.n1
                 lhs.ex = @c2.ex `union` @c1.ex
                 c1.scope = @lhs.scope
                 c2.scope = @lhs.scope
                 lhs.transformed = CConjunction @c1.transformed @c2.transformed
                 lhs.formula =   @c1.formula ++ " ^ " ++ @c2.formula
                 lhs.eye = CConjunction @c1.eye @c2.eye
                 lhs.eyeVar = @c2.eyeVar `union` @c1.eyeVar
                 lhs.eyeEx = @c2.eyeEx `union` @c1.eyeEx
                 c1.insideQuotation = @lhs.insideQuotation
                 c2.insideQuotation = @lhs.insideQuotation
                 lhs.diff = CConjunction @c1.diff @c2.diff
                 c1.c = @lhs.c
                 c2.c = @lhs.c
                 lhs.count = max @c1.count @c2.count
                 
sem Term
   | Universal lhs.n2 = ["U"++ @u]
               lhs.n1 = []
               lhs.ex = []
               lhs.transformed = Var  ("U"++ @u) 
               lhs.formula = "U"++ @u 
               lhs.eyeVar = ["U" ++ @u]
               lhs.eye = Var  ("U"++ @u)
               lhs.eyeEx = [] 
               lhs.diff = Var  ("U"++ @u) 
               lhs.count = 0
               

   | Existential lhs.n2 = []
                lhs.n1 = []
                lhs.ex = ["E"++ @ex]
                lhs.transformed = Var ("E"++ @ex)
                lhs.formula = "E"++ @ex
                lhs.eyeVar = []
                lhs.eye = Var ("E"++ @ex)
                lhs.eyeEx = ["E"++ @ex]
                lhs.diff = Var ("E"++ @ex)
                lhs.count = 0

   | URI lhs.n2 = []
              lhs.n1 = []
              lhs.ex = []
              lhs.transformed = Con ("uri_"++ @uri)
              lhs.formula = "uri_"++ @uri
              lhs.eyeVar = []
              lhs.eye = Con ("uri_" ++ @uri)
              lhs.eyeEx = []
              lhs.diff = Con ("uri_" ++ @uri)
              lhs.count = 0


   | Literal lhs.n2 = []
              lhs.n1 = []
              lhs.ex = []
              lhs.transformed = Con ("l_"++ @l)
              lhs.formula = "l_"++ @l
              lhs.eyeVar = []
              lhs.eye = Con ("l_"++ @l)
              lhs.eyeEx = []
              lhs.diff = Con ("l_"++ @l)
              lhs.count = 0
    
   | Exp  lhs.n2 = []
          lhs.n1 = @e.n1
          lhs.ex = []
          lhs.transformed = CExp @e.transformed 
          lhs.formula =  @e.formula
          lhs.eye = CExp @e.eye
          lhs.eyeEx= exception @lhs.varInImpException @lhs.insideQuotation @e.eyeEx
          e.insideQuotation = True
          lhs.diff = CExp @e.diff
          lhs.count= @e.count
           
--TODO how to get the transformed values of the elements?
   |List  lhs.n2 = @term.n2 ++ @list.n2
          lhs.n1 = []
          lhs.ex = @term.ex ++ @list.ex
          -- has to be adjusted
          lhs.transformed = CList @term.transformed @list.transformed
          lhs.formula =  "(" ++ @term.formula ++ "," ++ @list.formula ++ ")" 
          lhs.eyeVar = @term.eyeVar ++ @list.eyeVar
          lhs.eye = CList @term.transformed @list.transformed
          lhs.eyeEx = @term.eyeEx ++ @list.eyeEx
          lhs.diff = CList @term.diff @list.diff      
          term.c = @lhs.c
          list.c = @lhs.c
          lhs.count = max @term.count @list.count
                
                
          

sem Expression
   | BE lhs.n1 = []
          lhs.transformed = CBE @b
          lhs.formula = if @b == True then "<>" else "false"
          lhs.eyeVar = []
          lhs.eye = CBE @b
          lhs.eyeEx = []
          lhs.diff = CBE @b
          lhs.count = 0

   | FE   lhs.n1 = @f.n2
          f.scope = @lhs.scope `union` @f.n1 
          lhs.transformed = CFE (qua (@f.n1 \\ @lhs.scope) @f.ex @f.transformed)  
          lhs.formula = "<"++ (quaf (@f.n1 \\ @lhs.scope) @f.ex @f.formula) ++">"
          f.uni = @f.n1 \\ @lhs.scope
          lhs.eye = CFE (qua [] (imp @lhs.insideQuotation @f.eyeEx) @f.eye )
          lhs.eyeEx = @f.eyeEx
          lhs.diff = CFE (qua [] @f.ex @f.diff)
          f.insideQuotation = True
          f.c = @lhs.c+1
          lhs.count =  findDepth (@f.n1 \\ @lhs.scope) (@lhs.c +1) @f.count -- max (@lhs.c+1) @f.count
          



{

--TODO: pretty print
--TODO: clean up the ugly function!
{-
main ::  IO ()
main = case parse mainparser "" ":a :b :c." of
              { Left err -> print err
              ; Right ans -> print (  show (  transformed_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  )  )
              }
-}



             
parseToCoreTree :: String -> IO ()
parseToCoreTree filename = do {
                       input <- readFile filename
                       ; case runParser mainparser 0 filename input of
                       {
                       Left err -> print err
                       ; Right ans -> putStrLn $   show (  transformed_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  ) 
                       }
                       }  

              
eyeToCore :: String -> IO ()
eyeToCore fname = do {
               input <- readFile fname
              ; case runParser mainparser 0 fname input of
              { Left err -> print err
              ; Right ans -> putStrLn $ show (  eye_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  )  
              }}

parseToCoreFormula :: String -> IO ()
parseToCoreFormula fname = do {
                input <- readFile fname
                ; case runParser mainparser 0 fname input of
                { Left err -> print err
                ; Right ans -> print (  formula_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  ) )
                }
              }


testp :: String -> IO ()
testp fname = do {
                  input <- readFile fname
                  ; case runParser mainparser 0 fname input of
                  { Left err -> print err
                  ; Right ans -> putStrLn $   show (  eyeVar_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  ) 
                  } 
              }


-- function for quantifiers: takes Universals and existentials as lists and the formula without quantifier and produces a quantified formula
qua :: [String] -> [String] -> CFormula -> CFormula
--qua u e f = foldr fa f u
--fa :: String ->  CFormula
--fa  u f = Quant (Forall (Var u)) f

qua [] [] f  = f
qua [] (a:as) f = Quant (Forsome (Var a)) (qua [] as f)
qua (a:as) g f = Quant (Forall (Var a)) (qua as g f)





--the qua function to generate a formula (just to see the translation as text)
quaf :: [String] -> [String] -> String -> String
quaf [] [] s = s
quaf [] (a:as) s = "ForSome " ++ a ++ ". " ++ (quaf [] as s)
quaf (a:as) g s = "ForAll " ++ a ++ ". " ++ (quaf as g s)

findDepth :: [String] -> Int -> Int -> Int
findDepth [] n m = m
findDepth set n m = max n m




imp :: Bool -> [String] -> [String]
imp False l  = l
imp f l = []

--not really pretty, but at least easy
printTree :: String -> Int -> String 
printTree ('(':b) n = "\n"++ ( concat (replicate (n+1) "|  ") ) ++ ( printTree b (n+1) )
printTree (')':b) n = ( printTree b (n-1) )
printTree (s:b)   n  =  (s    : ( printTree b n))
printTree s       n  =  s 


makeTree :: String -> String -> IO()
makeTree fname "eye" = do {
                input <- readFile fname
                ; case runParser mainparser 0 fname input of
                { Left err -> print err
                ; Right ans -> putStrLn $ printTree  (show (  eye_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  )) 0
                }}
makeTree fname "cwm" = do {
                input <- readFile fname
                ; case runParser mainparser 0 fname input of
                { Left err -> print err
                ; Right ans -> putStrLn $ printTree  (show  (  transformed_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  )) 0
                }
                }
makeTree fname "uni" = do {
                input <- readFile fname
                ; case runParser mainparser 0 fname input of
                { Left err -> print err
                ; Right ans -> putStrLn $ printTree  (show  (  diff_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  )) 0
                }
                }


--really primitive function to compare tree strings, later that comparison should be on tree level
compareTree :: String -> String -> String -> Int -> String
compareTree (x:b) (y:c) s n 
           | (x==y) = compareTree b c (s++[x]) (n+1)
           | otherwise = "Difference at pos. "++ show(n)  ++ "\n" ++ s ++
                               "\n CWM:  " ++ (take 100 (x:b)) ++ "... \n and \n Other:  " ++ (take 100 (y:c))++ "..."
compareTree [][] s n = "no differences found"

compareB :: String -> IO()
compareB fname = do {
               input <- readFile fname
               ; case runParser mainparser 0 fname input of
                        { 
                          Left err -> print err
                          ; Right ans -> putStrLn $  compareTree (show (  transformed_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  )) 
                                                              (show (  eye_Syn_S         (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  ))
                                                              []
                                                              0
                        }
               }


topUni :: String -> IO()
topUni fname = do {
               input <- readFile fname
               ; case runParser mainparser 0 fname input of
                        { 
                          Left err -> print err
                          ; Right ans -> putStrLn $ show (  n1_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  ) 
  
                        }
               }






compareU :: String -> IO()
compareU fname = do {
               input <- readFile fname
               ; case runParser mainparser 0 fname input of
                        { 
                          Left err -> print err
                          ; Right ans -> putStrLn $  compareTree (show (  transformed_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  )) 
                                                              (show (  diff_Syn_S         (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  ))
                                                              []
                                                              0
                        }
               }
depth :: String -> IO()
depth fname =  do {
               input <- readFile fname
               ; case runParser mainparser 0 fname input of
                        { 
                          Left err -> print err
                          ; Right ans -> putStrLn $ show (  count_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  )
                        }
               }

compareAll :: String -> String ->  IO ()
compareAll foname target = do {
               
                files <- getDirectoryContents foname
                ; let fs = (drop 2 files)-- I guess I should solve that differently?
               -- ; let fname = head fs
               -- ;  input <- readFile (foname ++"/"++fname)
               -- ; case runParser mainparser 0 fname input of
               -- { Left err ->   writeFile "err.txt" (show err)
               -- ; Right ans ->  writeFile "out.txt" $ niceTable (read (show ans)) fname
                                
               -- }
               --this here is to only consider the files containing the symbol ?, only those can contain universals
               ;  newfs <- findFilesWithUniversals foname fs []
               ;   (values, count) <- (readAll foname newfs [] [0, 0, 0, 0])
               ; let table = makeTable newfs values count
               ; writeFile target $ ((replicate 40 ' ') ++ "cwm/es2  " ++ "cwm/eye  " ++ "eye/es2  " ++ "depth \n")++ table
               }


--readAll :: String -> [String] ->  -> IO() 
readAll foname [] list [a, b, c, d] = do { 
                            return $ ((reverse list), [a,b,c,d])
                            }
readAll foname fs list [a, b, c, d] = do { 
                         let fname = (head fs)
                         ; input <- readFile $ foname ++ "/"++ fname
                         ; print (foname ++ "/"++ fname ++ " parsed \n" )
                             
                                    ;case runParser mainparser 0 fname input of
                                    {
                                    Left  err ->   (readAll foname (tail fs) ( [2, 2, 2, 2 ]:list ) [a, b, c, d] )
                                    ;Right ans -> (\res -> ((\x y z zz zzz -> (readAll foname (tail fs) (
                                                             [x, 
                                                              y, 
                                                              z,
                                                              zz,
                                                              zzz  
                                                             ]:list ) 
                                                             [(a+x), (b+y), (c+z), (d+1) ]
                                                             ) )
                                                             (cwm_and_eye res )
                                                             (cwm_and_diff res)
                                                             (eye_and_diff res)
                                                             (boolToInt ( (eyeVar_Syn_S (  wrap_S  (sem_S  res) Inh_S   ))==[]))
                                                             (  count_Syn_S (  wrap_S  (sem_S  (read (show ans))) Inh_S  )  )
                                                             ))
                                                             (read (show ans))
                                   }
                               
                            
                            }
                         
findFilesWithUniversals foname [] newfs = do { return (reverse newfs) }                        
findFilesWithUniversals foname fs newfs = do {
                                             let fname = (head fs)
                                             ; input <- readFile $ foname ++ "/"++ fname
                                             ; case (isInfixOf "?" input) of
                                                   {
                                                   True  -> ( findFilesWithUniversals foname (tail fs) (fname:newfs))
                                                   ;False -> ( findFilesWithUniversals foname (tail fs) newfs)
                                                   }
                                             }


                       
                                  
--todo: every parsing only once               
cwm_and_eye :: S -> Int
cwm_and_eye f = boolToInt (( (show (  eye_Syn_S  x )) ==  ( show (  transformed_Syn_S x  )  ) ) ) 
           where x = (  wrap_S  (sem_S  f) Inh_S   )     
               
cwm_and_diff :: S -> Int
cwm_and_diff f = boolToInt (( (show (  diff_Syn_S  x )) ==  ( show (  transformed_Syn_S x  )  ) ) ) 
           where x = (  wrap_S  (sem_S  f) Inh_S   ) 

eye_and_diff :: S -> Int
eye_and_diff f = boolToInt (( (show (  diff_Syn_S  x )) ==  ( show (  eye_Syn_S x  )  ) ) ) 
           where x = (  wrap_S  (sem_S  f) Inh_S   ) 
           
           
niceTable :: S -> String -> String
niceTable f fname = (replicate 30 ' ') ++ "cwm/eye  " ++ "cwm/uni  " ++ "uni/eye \n" 
                     ++ fname ++ (replicate (30 - length(fname)) ' ')  ++ (show  ( cwm_and_eye f ))++ (replicate 8 ' ') ++ (show  ( cwm_and_diff f )) ++ (replicate 8 ' ') ++ (show  ( eye_and_diff f ))       


makeTable :: [String] -> [[Int]] -> [Int] -> String
makeTable [] values stat = lastLine stat
makeTable names ([a , b, c , 1, e]:v) [s1, s2, s3, s4] = (makeTable (tail names) v [(s1-a), (s2-b), (s3-c), (s4-1)])
makeTable names ([a , b, c , d, e]:v) stat = (head names) ++ (replicate (40 - length(head names)) ' ') ++ (concat $ fmap makeEntry [a, b, c, e]) ++ "\n"
                         ++ (makeTable (tail names) v stat)


lastLine :: [Int]-> String
lastLine [a,b,c, d] = "Absolute Number (from " 
                      ++ (show d) ++ "): " 
                      ++ (replicate(15 - (length(show d))) ' ')
                      ++ (show a) ++ (replicate (9 - (length(show a))) ' ')
                      ++ (show b) ++ (replicate (9 - (length(show b))) ' ')
                      ++ (show c) 
                      ++ "\n"
                      ++ "Percentage: "
                      ++ (show ((fromIntegral a)/(fromIntegral d)))
                      ++" "
                      ++ (show $ (fromIntegral b)/(fromIntegral d))
                      ++ " "
                      ++ (show $ (fromIntegral c)/(fromIntegral d))
 
makeEntry :: Int -> String 
makeEntry n = (show n) ++ (replicate 8 ' ')


--data TreeElem = CFormula | CTerm

-- function to compare trees
--compareTrees :: TreeElem -> TreeElem -> [(TreeElem, TreeElem)]
--compareTrees (CFormula rest)(CFormula rest2) = compareTrees rest rest2
--compareTrees (CTriple t1 t2 t3)(CTriple t11 t22 t33) = (compareTrees t1 t11)++(compareTrees t2 t22)++(compareTrees t3 t33)
--compareTrees a b = [(a,b)]

--compareTrees (Var x) (Var y) 
--            | (x == y) = []
--            | otherwise = [(x,y)]


boolToInt :: Bool -> Int
boolToInt False = 0
boolToInt True = 1

keepEx :: Bool -> [String] -> [String]
keepEx True l = l
keepEx False l = []

impExc :: CTerm -> Bool -> Bool
impExc (Con "uri_http://www.w3.org/2000/10/swap/log#implies") b = True
impExc t b = b 

exception :: Bool -> Bool -> [String] -> [String]
exception True False s = []
exception t    f s = s


boolToString :: Bool -> String
boolToString True = "TRUE"
boolToString False = "FALSE"


}























